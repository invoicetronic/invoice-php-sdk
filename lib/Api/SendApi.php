<?php
/**
 * SendApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Invoicetronic
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Italian eInvoice API
 *
 * The Italian eInvoice API is a RESTful API that allows you to send and receive invoices through the Italian [Servizio di Interscambio (SDI)][1], or Interchange Service. The API is designed by Invoicetronic to be simple and easy to use, abstracting away SDI complexity while providing complete control over the invoice send/receive process. The API also provides advanced features as encryption at rest, invoice validation, multiple upload formats, webhooks, event logging, client SDKs for commonly used languages, and CLI tools.  For more information, see  [Invoicetronic website][2]  [1]: https://www.fatturapa.gov.it/it/sistemainterscambio/cose-il-sdi/ [2]: https://invoicetronic.com/
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@invoicetronic.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.10.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Invoicetronic\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Invoicetronic\ApiException;
use Invoicetronic\Configuration;
use Invoicetronic\HeaderSelector;
use Invoicetronic\ObjectSerializer;

/**
 * SendApi Class Doc Comment
 *
 * @category Class
 * @package  Invoicetronic
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SendApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'invoiceV1SendFilesPost' => [
            'multipart/form-data',
        ],
        'invoiceV1SendGet' => [
            'application/json',
        ],
        'invoiceV1SendIdGet' => [
            'application/json',
        ],
        'invoiceV1SendJsonPost' => [
            'application/json',
        ],
        'invoiceV1SendPost' => [
            'application/json',
        ],
        'invoiceV1SendValidateFilesPost' => [
            'multipart/form-data',
        ],
        'invoiceV1SendValidateJsonPost' => [
            'application/json',
        ],
        'invoiceV1SendValidatePost' => [
            'application/json',
        ],
        'invoiceV1SendValidateXmlPost' => [
            'application/xml',
        ],
        'invoiceV1SendXmlPost' => [
            'application/xml',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation invoiceV1SendFilesPost
     *
     * Add an invoice by file
     *
     * @param  \SplFileObject[] $files files (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendFilesPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Invoicetronic\Model\Send|\Invoicetronic\Model\ProblemHttpResult|\Invoicetronic\Model\ProblemHttpResult
     */
    public function invoiceV1SendFilesPost($files, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendFilesPost'][0])
    {
        list($response) = $this->invoiceV1SendFilesPostWithHttpInfo($files, $validate, $signature, $contentType);
        return $response;
    }

    /**
     * Operation invoiceV1SendFilesPostWithHttpInfo
     *
     * Add an invoice by file
     *
     * @param  \SplFileObject[] $files (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendFilesPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Invoicetronic\Model\Send|\Invoicetronic\Model\ProblemHttpResult|\Invoicetronic\Model\ProblemHttpResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendFilesPostWithHttpInfo($files, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendFilesPost'][0])
    {
        $request = $this->invoiceV1SendFilesPostRequest($files, $validate, $signature, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Invoicetronic\Model\Send' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\Send' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\Send', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Invoicetronic\Model\Send';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\Send',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendFilesPostAsync
     *
     * Add an invoice by file
     *
     * @param  \SplFileObject[] $files (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendFilesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendFilesPostAsync($files, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendFilesPost'][0])
    {
        return $this->invoiceV1SendFilesPostAsyncWithHttpInfo($files, $validate, $signature, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendFilesPostAsyncWithHttpInfo
     *
     * Add an invoice by file
     *
     * @param  \SplFileObject[] $files (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendFilesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendFilesPostAsyncWithHttpInfo($files, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendFilesPost'][0])
    {
        $returnType = '\Invoicetronic\Model\Send';
        $request = $this->invoiceV1SendFilesPostRequest($files, $validate, $signature, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendFilesPost'
     *
     * @param  \SplFileObject[] $files (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendFilesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendFilesPostRequest($files, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendFilesPost'][0])
    {

        // verify the required parameter 'files' is set
        if ($files === null || (is_array($files) && count($files) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $files when calling invoiceV1SendFilesPost'
            );
        }




        $resourcePath = '/invoice/v1/send/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate,
            'validate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signature,
            'signature', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);



        // form params
        if ($files !== null) {
            $multipart = true;
            $formParams['files'] = [];
            $paramFiles = is_array($files) ? $files : [$files];
            foreach ($paramFiles as $paramFile) {
                $formParams['files'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceV1SendGet
     *
     * List invoices
     *
     * @param  int $company_id Company id (optional)
     * @param  string $identifier SDI identifier. (optional)
     * @param  string $committente Vat number or fiscal code. (optional)
     * @param  string $prestatore Vat number or fiscal code. (optional)
     * @param  string $file_name File name. (optional)
     * @param  \DateTime $last_update_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $last_update_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  string $document_number Document number. (optional)
     * @param  int $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendGet'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Invoicetronic\Model\Send[]|\Invoicetronic\Model\ProblemHttpResult
     */
    public function invoiceV1SendGet($company_id = null, $identifier = null, $committente = null, $prestatore = null, $file_name = null, $last_update_from = null, $last_update_to = null, $date_sent_from = null, $date_sent_to = null, $document_date_from = null, $document_date_to = null, $document_number = null, $page = 1, $page_size = 100, string $contentType = self::contentTypes['invoiceV1SendGet'][0])
    {
        list($response) = $this->invoiceV1SendGetWithHttpInfo($company_id, $identifier, $committente, $prestatore, $file_name, $last_update_from, $last_update_to, $date_sent_from, $date_sent_to, $document_date_from, $document_date_to, $document_number, $page, $page_size, $contentType);
        return $response;
    }

    /**
     * Operation invoiceV1SendGetWithHttpInfo
     *
     * List invoices
     *
     * @param  int $company_id Company id (optional)
     * @param  string $identifier SDI identifier. (optional)
     * @param  string $committente Vat number or fiscal code. (optional)
     * @param  string $prestatore Vat number or fiscal code. (optional)
     * @param  string $file_name File name. (optional)
     * @param  \DateTime $last_update_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $last_update_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  string $document_number Document number. (optional)
     * @param  int $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendGet'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Invoicetronic\Model\Send[]|\Invoicetronic\Model\ProblemHttpResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendGetWithHttpInfo($company_id = null, $identifier = null, $committente = null, $prestatore = null, $file_name = null, $last_update_from = null, $last_update_to = null, $date_sent_from = null, $date_sent_to = null, $document_date_from = null, $document_date_to = null, $document_number = null, $page = 1, $page_size = 100, string $contentType = self::contentTypes['invoiceV1SendGet'][0])
    {
        $request = $this->invoiceV1SendGetRequest($company_id, $identifier, $committente, $prestatore, $file_name, $last_update_from, $last_update_to, $date_sent_from, $date_sent_to, $document_date_from, $document_date_to, $document_number, $page, $page_size, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Invoicetronic\Model\Send[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\Send[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\Send[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Invoicetronic\Model\Send[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\Send[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendGetAsync
     *
     * List invoices
     *
     * @param  int $company_id Company id (optional)
     * @param  string $identifier SDI identifier. (optional)
     * @param  string $committente Vat number or fiscal code. (optional)
     * @param  string $prestatore Vat number or fiscal code. (optional)
     * @param  string $file_name File name. (optional)
     * @param  \DateTime $last_update_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $last_update_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  string $document_number Document number. (optional)
     * @param  int $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendGetAsync($company_id = null, $identifier = null, $committente = null, $prestatore = null, $file_name = null, $last_update_from = null, $last_update_to = null, $date_sent_from = null, $date_sent_to = null, $document_date_from = null, $document_date_to = null, $document_number = null, $page = 1, $page_size = 100, string $contentType = self::contentTypes['invoiceV1SendGet'][0])
    {
        return $this->invoiceV1SendGetAsyncWithHttpInfo($company_id, $identifier, $committente, $prestatore, $file_name, $last_update_from, $last_update_to, $date_sent_from, $date_sent_to, $document_date_from, $document_date_to, $document_number, $page, $page_size, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendGetAsyncWithHttpInfo
     *
     * List invoices
     *
     * @param  int $company_id Company id (optional)
     * @param  string $identifier SDI identifier. (optional)
     * @param  string $committente Vat number or fiscal code. (optional)
     * @param  string $prestatore Vat number or fiscal code. (optional)
     * @param  string $file_name File name. (optional)
     * @param  \DateTime $last_update_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $last_update_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  string $document_number Document number. (optional)
     * @param  int $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendGetAsyncWithHttpInfo($company_id = null, $identifier = null, $committente = null, $prestatore = null, $file_name = null, $last_update_from = null, $last_update_to = null, $date_sent_from = null, $date_sent_to = null, $document_date_from = null, $document_date_to = null, $document_number = null, $page = 1, $page_size = 100, string $contentType = self::contentTypes['invoiceV1SendGet'][0])
    {
        $returnType = '\Invoicetronic\Model\Send[]';
        $request = $this->invoiceV1SendGetRequest($company_id, $identifier, $committente, $prestatore, $file_name, $last_update_from, $last_update_to, $date_sent_from, $date_sent_to, $document_date_from, $document_date_to, $document_number, $page, $page_size, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendGet'
     *
     * @param  int $company_id Company id (optional)
     * @param  string $identifier SDI identifier. (optional)
     * @param  string $committente Vat number or fiscal code. (optional)
     * @param  string $prestatore Vat number or fiscal code. (optional)
     * @param  string $file_name File name. (optional)
     * @param  \DateTime $last_update_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $last_update_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $date_sent_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime $document_date_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  string $document_number Document number. (optional)
     * @param  int $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendGetRequest($company_id = null, $identifier = null, $committente = null, $prestatore = null, $file_name = null, $last_update_from = null, $last_update_to = null, $date_sent_from = null, $date_sent_to = null, $document_date_from = null, $document_date_to = null, $document_number = null, $page = 1, $page_size = 100, string $contentType = self::contentTypes['invoiceV1SendGet'][0])
    {
















        $resourcePath = '/invoice/v1/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company_id,
            'company_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $identifier,
            'identifier', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $committente,
            'committente', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prestatore,
            'prestatore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_name,
            'file_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_update_from,
            'last_update_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_update_to,
            'last_update_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_sent_from,
            'date_sent_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_sent_to,
            'date_sent_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date_from,
            'document_date_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_date_to,
            'document_date_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_number,
            'document_number', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceV1SendIdGet
     *
     * Get a invoice by id
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendIdGet'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Invoicetronic\Model\Send
     */
    public function invoiceV1SendIdGet($id, string $contentType = self::contentTypes['invoiceV1SendIdGet'][0])
    {
        list($response) = $this->invoiceV1SendIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation invoiceV1SendIdGetWithHttpInfo
     *
     * Get a invoice by id
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendIdGet'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Invoicetronic\Model\Send, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendIdGetWithHttpInfo($id, string $contentType = self::contentTypes['invoiceV1SendIdGet'][0])
    {
        $request = $this->invoiceV1SendIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Invoicetronic\Model\Send' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\Send' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\Send', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Invoicetronic\Model\Send';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\Send',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendIdGetAsync
     *
     * Get a invoice by id
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendIdGetAsync($id, string $contentType = self::contentTypes['invoiceV1SendIdGet'][0])
    {
        return $this->invoiceV1SendIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendIdGetAsyncWithHttpInfo
     *
     * Get a invoice by id
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendIdGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['invoiceV1SendIdGet'][0])
    {
        $returnType = '\Invoicetronic\Model\Send';
        $request = $this->invoiceV1SendIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendIdGet'
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendIdGetRequest($id, string $contentType = self::contentTypes['invoiceV1SendIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling invoiceV1SendIdGet'
            );
        }


        $resourcePath = '/invoice/v1/send/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceV1SendJsonPost
     *
     * Add an invoice by json
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendJsonPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Invoicetronic\Model\Send|\Invoicetronic\Model\ProblemHttpResult|\Invoicetronic\Model\ProblemHttpResult
     */
    public function invoiceV1SendJsonPost($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendJsonPost'][0])
    {
        list($response) = $this->invoiceV1SendJsonPostWithHttpInfo($fattura_ordinaria, $validate, $signature, $contentType);
        return $response;
    }

    /**
     * Operation invoiceV1SendJsonPostWithHttpInfo
     *
     * Add an invoice by json
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendJsonPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Invoicetronic\Model\Send|\Invoicetronic\Model\ProblemHttpResult|\Invoicetronic\Model\ProblemHttpResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendJsonPostWithHttpInfo($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendJsonPost'][0])
    {
        $request = $this->invoiceV1SendJsonPostRequest($fattura_ordinaria, $validate, $signature, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Invoicetronic\Model\Send' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\Send' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\Send', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Invoicetronic\Model\Send';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\Send',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendJsonPostAsync
     *
     * Add an invoice by json
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendJsonPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendJsonPostAsync($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendJsonPost'][0])
    {
        return $this->invoiceV1SendJsonPostAsyncWithHttpInfo($fattura_ordinaria, $validate, $signature, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendJsonPostAsyncWithHttpInfo
     *
     * Add an invoice by json
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendJsonPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendJsonPostAsyncWithHttpInfo($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendJsonPost'][0])
    {
        $returnType = '\Invoicetronic\Model\Send';
        $request = $this->invoiceV1SendJsonPostRequest($fattura_ordinaria, $validate, $signature, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendJsonPost'
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendJsonPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendJsonPostRequest($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendJsonPost'][0])
    {

        // verify the required parameter 'fattura_ordinaria' is set
        if ($fattura_ordinaria === null || (is_array($fattura_ordinaria) && count($fattura_ordinaria) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fattura_ordinaria when calling invoiceV1SendJsonPost'
            );
        }




        $resourcePath = '/invoice/v1/send/json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate,
            'validate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signature,
            'signature', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fattura_ordinaria)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fattura_ordinaria));
            } else {
                $httpBody = $fattura_ordinaria;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceV1SendPost
     *
     * Add an invoice
     *
     * @param  \Invoicetronic\Model\Send $send send (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Invoicetronic\Model\Send|\Invoicetronic\Model\ProblemHttpResult|\Invoicetronic\Model\ProblemHttpResult
     */
    public function invoiceV1SendPost($send, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendPost'][0])
    {
        list($response) = $this->invoiceV1SendPostWithHttpInfo($send, $validate, $signature, $contentType);
        return $response;
    }

    /**
     * Operation invoiceV1SendPostWithHttpInfo
     *
     * Add an invoice
     *
     * @param  \Invoicetronic\Model\Send $send (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Invoicetronic\Model\Send|\Invoicetronic\Model\ProblemHttpResult|\Invoicetronic\Model\ProblemHttpResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendPostWithHttpInfo($send, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendPost'][0])
    {
        $request = $this->invoiceV1SendPostRequest($send, $validate, $signature, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Invoicetronic\Model\Send' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\Send' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\Send', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Invoicetronic\Model\Send';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\Send',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendPostAsync
     *
     * Add an invoice
     *
     * @param  \Invoicetronic\Model\Send $send (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendPostAsync($send, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendPost'][0])
    {
        return $this->invoiceV1SendPostAsyncWithHttpInfo($send, $validate, $signature, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendPostAsyncWithHttpInfo
     *
     * Add an invoice
     *
     * @param  \Invoicetronic\Model\Send $send (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendPostAsyncWithHttpInfo($send, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendPost'][0])
    {
        $returnType = '\Invoicetronic\Model\Send';
        $request = $this->invoiceV1SendPostRequest($send, $validate, $signature, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendPost'
     *
     * @param  \Invoicetronic\Model\Send $send (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendPostRequest($send, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendPost'][0])
    {

        // verify the required parameter 'send' is set
        if ($send === null || (is_array($send) && count($send) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $send when calling invoiceV1SendPost'
            );
        }




        $resourcePath = '/invoice/v1/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate,
            'validate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signature,
            'signature', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($send)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($send));
            } else {
                $httpBody = $send;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceV1SendValidateFilesPost
     *
     * Validate an invoice by file
     *
     * @param  \SplFileObject[] $files files (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateFilesPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceV1SendValidateFilesPost($files, string $contentType = self::contentTypes['invoiceV1SendValidateFilesPost'][0])
    {
        $this->invoiceV1SendValidateFilesPostWithHttpInfo($files, $contentType);
    }

    /**
     * Operation invoiceV1SendValidateFilesPostWithHttpInfo
     *
     * Validate an invoice by file
     *
     * @param  \SplFileObject[] $files (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateFilesPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendValidateFilesPostWithHttpInfo($files, string $contentType = self::contentTypes['invoiceV1SendValidateFilesPost'][0])
    {
        $request = $this->invoiceV1SendValidateFilesPostRequest($files, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendValidateFilesPostAsync
     *
     * Validate an invoice by file
     *
     * @param  \SplFileObject[] $files (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateFilesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendValidateFilesPostAsync($files, string $contentType = self::contentTypes['invoiceV1SendValidateFilesPost'][0])
    {
        return $this->invoiceV1SendValidateFilesPostAsyncWithHttpInfo($files, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendValidateFilesPostAsyncWithHttpInfo
     *
     * Validate an invoice by file
     *
     * @param  \SplFileObject[] $files (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateFilesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendValidateFilesPostAsyncWithHttpInfo($files, string $contentType = self::contentTypes['invoiceV1SendValidateFilesPost'][0])
    {
        $returnType = '';
        $request = $this->invoiceV1SendValidateFilesPostRequest($files, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendValidateFilesPost'
     *
     * @param  \SplFileObject[] $files (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateFilesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendValidateFilesPostRequest($files, string $contentType = self::contentTypes['invoiceV1SendValidateFilesPost'][0])
    {

        // verify the required parameter 'files' is set
        if ($files === null || (is_array($files) && count($files) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $files when calling invoiceV1SendValidateFilesPost'
            );
        }


        $resourcePath = '/invoice/v1/send/validate/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($files !== null) {
            $multipart = true;
            $formParams['files'] = [];
            $paramFiles = is_array($files) ? $files : [$files];
            foreach ($paramFiles as $paramFile) {
                $formParams['files'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceV1SendValidateJsonPost
     *
     * Validate an invoice by json
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateJsonPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceV1SendValidateJsonPost($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateJsonPost'][0])
    {
        $this->invoiceV1SendValidateJsonPostWithHttpInfo($fattura_ordinaria, $contentType);
    }

    /**
     * Operation invoiceV1SendValidateJsonPostWithHttpInfo
     *
     * Validate an invoice by json
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateJsonPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendValidateJsonPostWithHttpInfo($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateJsonPost'][0])
    {
        $request = $this->invoiceV1SendValidateJsonPostRequest($fattura_ordinaria, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendValidateJsonPostAsync
     *
     * Validate an invoice by json
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateJsonPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendValidateJsonPostAsync($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateJsonPost'][0])
    {
        return $this->invoiceV1SendValidateJsonPostAsyncWithHttpInfo($fattura_ordinaria, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendValidateJsonPostAsyncWithHttpInfo
     *
     * Validate an invoice by json
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateJsonPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendValidateJsonPostAsyncWithHttpInfo($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateJsonPost'][0])
    {
        $returnType = '';
        $request = $this->invoiceV1SendValidateJsonPostRequest($fattura_ordinaria, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendValidateJsonPost'
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateJsonPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendValidateJsonPostRequest($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateJsonPost'][0])
    {

        // verify the required parameter 'fattura_ordinaria' is set
        if ($fattura_ordinaria === null || (is_array($fattura_ordinaria) && count($fattura_ordinaria) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fattura_ordinaria when calling invoiceV1SendValidateJsonPost'
            );
        }


        $resourcePath = '/invoice/v1/send/validate/json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fattura_ordinaria)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fattura_ordinaria));
            } else {
                $httpBody = $fattura_ordinaria;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceV1SendValidatePost
     *
     * Validate an invoice
     *
     * @param  \Invoicetronic\Model\Send $send send (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidatePost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceV1SendValidatePost($send, string $contentType = self::contentTypes['invoiceV1SendValidatePost'][0])
    {
        $this->invoiceV1SendValidatePostWithHttpInfo($send, $contentType);
    }

    /**
     * Operation invoiceV1SendValidatePostWithHttpInfo
     *
     * Validate an invoice
     *
     * @param  \Invoicetronic\Model\Send $send (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidatePost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendValidatePostWithHttpInfo($send, string $contentType = self::contentTypes['invoiceV1SendValidatePost'][0])
    {
        $request = $this->invoiceV1SendValidatePostRequest($send, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendValidatePostAsync
     *
     * Validate an invoice
     *
     * @param  \Invoicetronic\Model\Send $send (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendValidatePostAsync($send, string $contentType = self::contentTypes['invoiceV1SendValidatePost'][0])
    {
        return $this->invoiceV1SendValidatePostAsyncWithHttpInfo($send, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendValidatePostAsyncWithHttpInfo
     *
     * Validate an invoice
     *
     * @param  \Invoicetronic\Model\Send $send (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendValidatePostAsyncWithHttpInfo($send, string $contentType = self::contentTypes['invoiceV1SendValidatePost'][0])
    {
        $returnType = '';
        $request = $this->invoiceV1SendValidatePostRequest($send, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendValidatePost'
     *
     * @param  \Invoicetronic\Model\Send $send (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendValidatePostRequest($send, string $contentType = self::contentTypes['invoiceV1SendValidatePost'][0])
    {

        // verify the required parameter 'send' is set
        if ($send === null || (is_array($send) && count($send) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $send when calling invoiceV1SendValidatePost'
            );
        }


        $resourcePath = '/invoice/v1/send/validate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($send)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($send));
            } else {
                $httpBody = $send;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceV1SendValidateXmlPost
     *
     * Validate an invoice by xml
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateXmlPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceV1SendValidateXmlPost($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateXmlPost'][0])
    {
        $this->invoiceV1SendValidateXmlPostWithHttpInfo($fattura_ordinaria, $contentType);
    }

    /**
     * Operation invoiceV1SendValidateXmlPostWithHttpInfo
     *
     * Validate an invoice by xml
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateXmlPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendValidateXmlPostWithHttpInfo($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateXmlPost'][0])
    {
        $request = $this->invoiceV1SendValidateXmlPostRequest($fattura_ordinaria, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendValidateXmlPostAsync
     *
     * Validate an invoice by xml
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateXmlPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendValidateXmlPostAsync($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateXmlPost'][0])
    {
        return $this->invoiceV1SendValidateXmlPostAsyncWithHttpInfo($fattura_ordinaria, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendValidateXmlPostAsyncWithHttpInfo
     *
     * Validate an invoice by xml
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateXmlPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendValidateXmlPostAsyncWithHttpInfo($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateXmlPost'][0])
    {
        $returnType = '';
        $request = $this->invoiceV1SendValidateXmlPostRequest($fattura_ordinaria, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendValidateXmlPost'
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendValidateXmlPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendValidateXmlPostRequest($fattura_ordinaria, string $contentType = self::contentTypes['invoiceV1SendValidateXmlPost'][0])
    {

        // verify the required parameter 'fattura_ordinaria' is set
        if ($fattura_ordinaria === null || (is_array($fattura_ordinaria) && count($fattura_ordinaria) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fattura_ordinaria when calling invoiceV1SendValidateXmlPost'
            );
        }


        $resourcePath = '/invoice/v1/send/validate/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fattura_ordinaria)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fattura_ordinaria));
            } else {
                $httpBody = $fattura_ordinaria;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceV1SendXmlPost
     *
     * Add an invoice by xml
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendXmlPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Invoicetronic\Model\Send|\Invoicetronic\Model\ProblemHttpResult|\Invoicetronic\Model\ProblemHttpResult
     */
    public function invoiceV1SendXmlPost($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendXmlPost'][0])
    {
        list($response) = $this->invoiceV1SendXmlPostWithHttpInfo($fattura_ordinaria, $validate, $signature, $contentType);
        return $response;
    }

    /**
     * Operation invoiceV1SendXmlPostWithHttpInfo
     *
     * Add an invoice by xml
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendXmlPost'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Invoicetronic\Model\Send|\Invoicetronic\Model\ProblemHttpResult|\Invoicetronic\Model\ProblemHttpResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceV1SendXmlPostWithHttpInfo($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendXmlPost'][0])
    {
        $request = $this->invoiceV1SendXmlPostRequest($fattura_ordinaria, $validate, $signature, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Invoicetronic\Model\Send' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\Send' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\Send', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Invoicetronic\Model\Send';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\Send',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invoiceV1SendXmlPostAsync
     *
     * Add an invoice by xml
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendXmlPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendXmlPostAsync($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendXmlPost'][0])
    {
        return $this->invoiceV1SendXmlPostAsyncWithHttpInfo($fattura_ordinaria, $validate, $signature, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceV1SendXmlPostAsyncWithHttpInfo
     *
     * Add an invoice by xml
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendXmlPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceV1SendXmlPostAsyncWithHttpInfo($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendXmlPost'][0])
    {
        $returnType = '\Invoicetronic\Model\Send';
        $request = $this->invoiceV1SendXmlPostRequest($fattura_ordinaria, $validate, $signature, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceV1SendXmlPost'
     *
     * @param  \Invoicetronic\Model\FatturaOrdinaria $fattura_ordinaria (required)
     * @param  bool $validate Validate the document first, and reject it on failure. (optional, default to false)
     * @param  string $signature Whether to digitally sign the document. (optional, default to 'Auto')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceV1SendXmlPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceV1SendXmlPostRequest($fattura_ordinaria, $validate = false, $signature = 'Auto', string $contentType = self::contentTypes['invoiceV1SendXmlPost'][0])
    {

        // verify the required parameter 'fattura_ordinaria' is set
        if ($fattura_ordinaria === null || (is_array($fattura_ordinaria) && count($fattura_ordinaria) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fattura_ordinaria when calling invoiceV1SendXmlPost'
            );
        }




        $resourcePath = '/invoice/v1/send/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate,
            'validate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $signature,
            'signature', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fattura_ordinaria)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fattura_ordinaria));
            } else {
                $httpBody = $fattura_ordinaria;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
